<!DOCTYPE html>
<html>
<head>
    <title>Simulation Viewer</title>
    <style>
        body {
            display: flex;
            flex-direction: row;
            background: #000000;
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }
        .canvas-container {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border: none;
            margin: 0;
            max-width: 99vw;
            max-height: 100vh;
            height: auto;
        }
        .controls {
            position: relative;
            z-index: 1;
            margin: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 120px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            transition: opacity 0.3s ease;
        }
        .controls.hidden {
            opacity: 0;
            pointer-events: none;
        }
        input[type="file"] {
            color: white;
        }
        button {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .frame-nav {
            display: flex;
            gap: 4px;
            display: none;
        }
        .frame-nav button {
            flex: 1;
            padding: 8px 8px;
        }
        .toggle-container {
            display: flex;
            align-items: center;
            display: none;
        }
        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .w-controls {
            display: flex;
            gap: 4px;
            align-items: center;
            display: none;
        }
        .slice-controls {
            display: none;
            gap: 4px;
            align-items: center;
        }
        .w-value, .slice-value {
            text-align: center;
            min-width: 40px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        #dimensionDisplay {
            font-size: 18px;
            text-align: center;
            margin-bottom: 10px;
        }
        .playback-controls {
            display: none;
        }
        #frameCounter {
            text-align: center;
            font-size: 14px;
            margin: 5px 0;
            display: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="controls">
        <div id="dimensionDisplay">No file loaded</div>
        <input type="file" id="fileInput" multiple accept=".json">
        <div class="playback-controls">
            <button id="playPauseButton">Play</button>
            <button id="restartButton">Restart</button>
            <div id="frameCounter">Frame: 0/0</div>
        </div>
        <div class="frame-nav">
            <button id="prevFrameButton">◀</button>
            <button id="nextFrameButton">▶</button>
        </div>
        <div class="w-controls" id="wControls">
            <button id="decreaseWButton">W-</button>
            <div class="w-value" id="wValue">W: 0</div>
            <button id="increaseWButton">W+</button>
        </div>
        <div class="slice-controls" id="sliceControls">
            <label class="toggle">
                <input type="checkbox" id="sliceToggle">
                <span class="toggle-label">Slice View</span>
            </label>
            <button id="decreaseSliceButton">-</button>
            <div class="slice-value" id="sliceValue">±0</div>
            <button id="increaseSliceButton">+</button>
        </div>
        <div class="toggle-container">
            <label class="toggle">
                <input type="checkbox" id="loopToggle" checked>
                <span class="toggle-label">Loop</span>
            </label>
        </div>
        <div class="rotation-toggle" style="display: none;">
            <label class="toggle">
                <input type="checkbox" id="rotationToggle" checked>
                <span class="toggle-label">Auto-Rotate</span>
            </label>
        </div>
    </div>

    <div class="canvas-container" id="canvas-container">
        <canvas id="leniaCanvas"></canvas>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let frames = [];
        let currentFrame = 0;
        let isPlaying = false;
        let animationId = null;
        let cubeInstances = new Map();
        let currentW = 0;
        let wMin = 0, wMax = 0;
        let dimensions = 0;
        let globalMinX = 0, globalMaxX = 0, globalMinY = 0, globalMaxY = 0;
        let isFullscreen = false;
        let sliceThickness = 0;
        let maxSliceThickness = 5;
        
        const canvas = document.getElementById('leniaCanvas');
        const ctx = canvas.getContext('2d');
        const frameCounter = document.getElementById('frameCounter');
        const controlsElement = document.querySelector('.controls');
        const sliceToggle = document.getElementById('sliceToggle');
        const sliceControls = document.getElementById('sliceControls');
        
        // Simplified zoom state
        let currentScale = 1;
        let targetScale = 1;
        const ZOOM_FACTOR = 0.1;
        const SCALE_CHANGE_SPEED = 0.15;
        let animationFrameId = null;
        
        // Initialize Three.js scene for 3D/4D
        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            renderer.physicallyCorrectLights = true;
            
            // Clear existing canvas
            canvas.style.display = 'none';
            const existingRenderer = document.querySelector('canvas');
            if (existingRenderer) {
                existingRenderer.remove();
            }
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            resetCamera();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const lights = [
                { pos: [10, 10, 10], intensity: 0.8 },
                { pos: [-10, -10, -10], intensity: 0.6 },
                { pos: [10, -10, 10], intensity: 0.7 },
                { pos: [-10, 10, -10], intensity: 0.7 }
            ];

            lights.forEach(light => {
                const directionalLight = new THREE.DirectionalLight(0xffffff, light.intensity);
                directionalLight.position.set(...light.pos);
                scene.add(directionalLight);
            });

            animate3D();
        }

        function resetCamera() {
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            if (controls) {
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        function init2D() {
            // Clear Three.js renderer if exists
            const existingRenderer = document.querySelector('canvas:not(#leniaCanvas)');
            if (existingRenderer) {
                existingRenderer.remove();
            }
            canvas.style.display = 'block';
            
            // Reset zoom state
            currentScale = 1;
            targetScale = 1;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Set up 2D canvas using global bounds
            const baseSize = Math.min(window.innerWidth * 0.99, window.innerHeight * 0.95);
            canvas.width = baseSize;
            canvas.height = baseSize;
        }

        function detectDimensions(frameData) {
            if (!frameData || !frameData.cells || frameData.cells.length === 0) return 0;
            const cell = frameData.cells[0];
            if (cell.hasOwnProperty('w')) return 4;
            if (cell.hasOwnProperty('z')) return 3;
            if (cell.hasOwnProperty('x') && cell.hasOwnProperty('y')) return 2;
            return 0;
        }

        function calculateGlobalBounds() {
            globalMinX = Infinity;
            globalMaxX = -Infinity;
            globalMinY = Infinity;
            globalMaxY = -Infinity;

            frames.forEach(frame => {
                frame.cells.forEach(cell => {
                    globalMinX = Math.min(globalMinX, cell.x);
                    globalMaxX = Math.max(globalMaxX, cell.x);
                    globalMinY = Math.min(globalMinY, cell.y);
                    globalMaxY = Math.max(globalMaxY, cell.y);
                });
            });
        }

        fileInput.addEventListener('change', async (e) => {
            frames = [];
            const files = Array.from(e.target.files).sort((a, b) => {
                const numA = parseInt(a.name.match(/\d+/)[0]);
                const numB = parseInt(b.name.match(/\d+/)[0]);
                return numA - numB;
            });

            if (files.length === 0) return;

            // Load first frame to detect dimensions
            const firstFrameText = await files[0].text();
            const firstFrameData = JSON.parse(firstFrameText);
            dimensions = detectDimensions(firstFrameData);
            
            document.getElementById('dimensionDisplay').textContent = `${dimensions}D Visualization`;
            document.getElementById('wControls').style.display = dimensions === 4 ? 'flex' : 'none';
            document.getElementById('sliceControls').style.display = dimensions === 3 ? 'flex' : 'none';
            document.querySelector('.frame-nav').style.display = 'flex';
            document.querySelector('.toggle-container').style.display = 'flex';
            document.querySelector('.playback-controls').style.display = 'block';
            document.querySelector('.rotation-toggle').style.display = dimensions >= 3 ? 'block' : 'none';
            frameCounter.style.display = 'block';

            // Load all frames
            for (const file of files) {
                const text = await file.text();
                const frameData = JSON.parse(text);
                frames.push(frameData);
            }

            // Calculate global bounds for 2D animations
            if (dimensions === 2) {
                calculateGlobalBounds();
            }

            // Initialize appropriate viewer
            if (dimensions === 2) {
                init2D();
            } else if (dimensions >= 3) {
                init3D();
            }

            // Reset simulation state
            currentFrame = 0;
            currentW = 0;
            sliceThickness = 0;
            
            // Start paused at frame 0
            isPlaying = false;
            playPauseButton.textContent = 'Play';
            if (dimensions === 4) updateWBounds();
            updateFrameCounter();
            drawFrame(currentFrame);
            
            // If 3D/4D, just render the first frame
            if (dimensions >= 3) {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                draw3DFrame(currentFrame);
            }
        });

        function createCube(x, y, z, value) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: value,
                roughness: 0.3,
                metalness: 0.2,
                emissive: 0xffffff,
                emissiveIntensity: value * 0.8
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            return cube;
        }

        function smoothScale() {
            if (Math.abs(targetScale - currentScale) > 0.001) {
                currentScale += (targetScale - currentScale) * SCALE_CHANGE_SPEED;
                console.log('Updating scale:', currentScale);
                drawFrame(currentFrame);
                animationFrameId = requestAnimationFrame(smoothScale);
            } else {
                console.log('Animation complete');
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function draw2DFrame(frameIndex) {
            const frame = frames[frameIndex];
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate the base scale to fit the simulation in the canvas
            const width = globalMaxX - globalMinX;
            const height = globalMaxY - globalMinY;
            const baseScale = Math.min(
                (canvas.width * 0.9) / width,
                (canvas.height * 0.9) / height
            );
            
            // Apply current scale factor
            const finalScale = baseScale * currentScale;
            
            // Center the simulation
            const offsetX = (canvas.width - width * finalScale) / 2;
            const offsetY = (canvas.height - height * finalScale) / 2;

            // Draw cells
            frame.cells.forEach(cell => {
                const x = (cell.x - globalMinX) * finalScale + offsetX;
                const y = (cell.y - globalMinY) * finalScale + offsetY;
                const cellSize = Math.max(1, finalScale);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${cell.value})`;
                ctx.fillRect(x, y, cellSize, cellSize);
            });
        }

        function draw3DFrame(frameIndex) {
            cubeInstances.forEach(cube => scene.remove(cube));
            cubeInstances.clear();

            const frame = frames[frameIndex];
            let cells = dimensions === 4 ? 
                frame.cells.filter(cell => cell.w === currentW) :
                frame.cells;

            // Apply slice filter if enabled
            if (dimensions === 3 && sliceToggle.checked) {
                cells = cells.filter(cell => Math.abs(cell.x) <= sliceThickness);
            }

            cells.forEach(cell => {
                const key = `${cell.x},${cell.y},${cell.z}`;
                const cube = createCube(cell.x, cell.y, cell.z, cell.value);
                scene.add(cube);
                cubeInstances.set(key, cube);
            });
        }

        function drawFrame(frameIndex) {
            if (!frames || frames.length === 0) return;
            
            if (dimensions === 2) {
                draw2DFrame(frameIndex);
            } else {
                draw3DFrame(frameIndex);
            }
            updateFrameCounter();
        }

        function updateFrameCounter() {
            frameCounter.textContent = `Frame: ${currentFrame + 1}/${frames.length}`;
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (controls) controls.update();
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        let lastFrameTime = 0;
        const frameDelay = 1000 / 30;

        function updateAnimation(timestamp) {
            if (!isPlaying) return;
            
            const elapsed = timestamp - lastFrameTime;
            
            if (elapsed > frameDelay) {
                drawFrame(currentFrame);
                currentFrame++;
                
                if (currentFrame >= frames.length) {
                    if (loopToggle.checked) {
                        currentFrame = 0;
                    } else {
                        currentFrame = frames.length - 1;
                        isPlaying = false;
                        return;
                    }
                }
                
                lastFrameTime = timestamp;
            }
            
            animationId = requestAnimationFrame(updateAnimation);
        }

        // Event Listeners
        playPauseButton.addEventListener('click', () => {
            if (!frames.length) return;
            isPlaying = !isPlaying;
            playPauseButton.textContent = isPlaying ? 'Pause' : 'Play';
            if (isPlaying) {
                updateAnimation();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });

        restartButton.addEventListener('click', () => {
            isPlaying = false;
            if (animationId) cancelAnimationFrame(animationId);
            currentFrame = 0;
            drawFrame(currentFrame);
            playPauseButton.textContent = 'Play';
        });

        prevFrameButton.addEventListener('click', () => {
            isPlaying = false;
            if (animationId) cancelAnimationFrame(animationId);
            currentFrame = (currentFrame - 1 + frames.length) % frames.length;
            drawFrame(currentFrame);
            playPauseButton.textContent = 'Play';
        });

        nextFrameButton.addEventListener('click', () => {
            isPlaying = false;
            if (animationId) cancelAnimationFrame(animationId);
            currentFrame = (currentFrame + 1) % frames.length;
            drawFrame(currentFrame);
            playPauseButton.textContent = 'Play';
        });

        // 4D specific controls
        function updateWBounds() {
            if (!frames || frames.length === 0) return;
            const frame = frames[currentFrame];
            wMin = Math.min(...frame.cells.map(cell => cell.w));
            wMax = Math.max(...frame.cells.map(cell => cell.w));
            currentW = Math.max(wMin, Math.min(wMax, currentW));
            document.getElementById('wValue').textContent = `W: ${currentW}`;
        }

        decreaseWButton.addEventListener('click', () => {
            if (currentW > wMin) {
                currentW--;
                document.getElementById('wValue').textContent = `W: ${currentW}`;
                drawFrame(currentFrame);
            }
        });

        increaseWButton.addEventListener('click', () => {
            if (currentW < wMax) {
                currentW++;
                document.getElementById('wValue').textContent = `W: ${currentW}`;
                drawFrame(currentFrame);
            }
        });

        // Slice controls
        sliceToggle.addEventListener('change', () => {
            drawFrame(currentFrame);
        });

        document.getElementById('decreaseSliceButton').addEventListener('click', () => {
            if (sliceThickness > 0) {
                sliceThickness--;
                document.getElementById('sliceValue').textContent = `±${sliceThickness}`;
                drawFrame(currentFrame);
            }
        });

        document.getElementById('increaseSliceButton').addEventListener('click', () => {
            if (sliceThickness < maxSliceThickness) {
                sliceThickness++;
                document.getElementById('sliceValue').textContent = `±${sliceThickness}`;
                drawFrame(currentFrame);
            }
        });

        window.addEventListener('resize', () => {
            if (dimensions >= 3) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            } else if (dimensions === 2) {
                init2D();
                drawFrame(currentFrame);
            }
        });

        // Fullscreen toggle with F key
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'f') {
                isFullscreen = !isFullscreen;
                
                if (isFullscreen) {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen();
                    }
                    controlsElement.classList.add('hidden');
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                    controlsElement.classList.remove('hidden');
                }
            }
        });

        // Move wheel event listener to window level and add checks
        window.addEventListener('wheel', (e) => {
            if (dimensions !== 2) return;
            
            // Check if mouse is over controls
            const controlsElement = document.querySelector('.controls');
            if (controlsElement.contains(e.target)) return;
            
            e.preventDefault();
            
            // Debug logs
            console.log('Wheel event detected');
            console.log('Current target:', e.target);
            console.log('Current scale:', currentScale);
            console.log('Delta Y:', e.deltaY);
            
            // Update target scale based on wheel direction
            const scaleFactor = e.deltaY > 0 ? (1 - ZOOM_FACTOR) : (1 + ZOOM_FACTOR);
            targetScale *= scaleFactor;
            
            console.log('New target scale:', targetScale);
            
            // Start smooth scale animation if not already running
            if (!animationFrameId) {
                console.log('Starting animation');
                smoothScale();
            }
        }, { passive: false });

        // Add rotation toggle handler
        const rotationToggle = document.getElementById('rotationToggle');
        rotationToggle.addEventListener('change', () => {
            if (controls) {
                controls.autoRotate = rotationToggle.checked;
            }
        });
    </script>
</body>
</html>